// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IAdobeHouse {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract StakingContract {
    IAdobeHouse private tokenContract;
    uint256 private constant MIN_STAKE_AMOUNT = 100 * 10**18; // Assuming 18 decimals
    uint256 private constant CONTRACT_EXPIRATION_TIMESTAMP = 1672444800; // End of 2024
    uint256 private constant PENALTY_PERCENTAGE = 50; // 50% penalty for early unstaking

    // APY values hard-coded into the contract
    uint256 private constant ONE_MONTH_APY = 3; // 3% for one month
    uint256 private constant ONE_YEAR_APY = 15; // 15% for one year

    enum StakingDuration { OneMonth, OneYear }

    struct StakeInfo {
        uint256 amount;
        uint256 startTime;
        StakingDuration duration;
    }

    mapping(address => StakeInfo) private stakingInfo;

    constructor(address _tokenContract) {
        require(_tokenContract != address(0), "Invalid token contract address");
        tokenContract = IAdobeHouse(_tokenContract);
    }

    function stakeTokens(uint256 amount, StakingDuration duration) external {
        require(msg.sender != address(0), "Invalid staker address");
        require(amount >= MIN_STAKE_AMOUNT, "Amount must be greater than the minimum stake amount");
        require(tokenContract.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        stakingInfo[msg.sender] = StakeInfo({
            amount: amount,
            startTime: block.timestamp,
            duration: duration
        });
    }

    function unstakeTokens() external {
        require(msg.sender != address(0), "Invalid staker address");
        StakeInfo storage stake = stakingInfo[msg.sender];
        require(stake.amount > 0, "No staked tokens to unstake");

        // Calculate reward
        uint256 reward = calculateReward(stake);

        // Apply penalty if unstaking before the set period
        if (block.timestamp < stake.startTime + stakingPeriod(stake.duration)) {
            reward = (reward * (100 - PENALTY_PERCENTAGE)) / 100;
        }

        uint256 totalAmount = stake.amount + reward;

        // Transfer staked tokens and reward back to the staker
        require(tokenContract.transfer(msg.sender, totalAmount), "Transfer failed");

        // Reset staking info
        delete stakingInfo[msg.sender];
    }

    function stakingPeriod(StakingDuration duration) private pure returns (uint256) {
        if (duration == StakingDuration.OneMonth) return 30 days;
        if (duration == StakingDuration.OneYear) return 365 days;
        revert("Invalid staking duration");
    }

    function calculateReward(StakeInfo memory stake) private pure returns (uint256) {
        if (block.timestamp >= CONTRACT_EXPIRATION_TIMESTAMP) return 0;

        uint256 stakingPeriod = block.timestamp - stake.startTime;
        uint256 annualRewardRate;

        if (stake.duration == StakingDuration.OneMonth) {
            annualRewardRate = ONE_MONTH_APY; // 3%
        } else { // OneYear
            annualRewardRate = ONE_YEAR_APY; // 15%
        }

        // Calculate the reward using higher intermediate precision
        uint256 reward = stake.amount * annualRewardRate * stakingPeriod;

        // Divide by 100 (for percentage) and 365 days (for annualization)
        reward = reward / (100 * 365 days);

        // If staking for less than a year, apply pro-rata calculation
        if (stakingPeriod < 365 days) {
            reward = (reward * stakingPeriod) / (365 days);
        }

        return reward;
    }
}
